<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Labubu AR (åŒæ‘„ç‰ˆ)</title>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        #input-video { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; z-index: 1; transform: scaleX(-1); /* é»˜è®¤å‰ç½®é•œåƒ */ }
        #output-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; pointer-events: none; transform: scaleX(-1); /* é»˜è®¤å‰ç½®é•œåƒ */ }
        
        /* é®ç½©å±‚ */
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); z-index: 100;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: white; transition: opacity 0.5s;
        }

        /* å¼€å§‹æŒ‰é’® */
        #start-btn {
            padding: 15px 40px; font-size: 18px; background: #00C853; color: white;
            border: none; border-radius: 30px; font-weight: bold; cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 200, 83, 0.4); margin-bottom: 20px;
        }
        #start-btn:disabled { background: #555; color: #888; box-shadow: none; }

        /* åˆ‡æ¢æ‘„åƒå¤´æŒ‰é’® (é»˜è®¤éšè—ï¼Œå¯åŠ¨åæ˜¾ç¤º) */
        #switch-btn {
            position: absolute; top: 20px; right: 20px; z-index: 99;
            background: rgba(255, 255, 255, 0.3); color: white;
            border: 1px solid rgba(255,255,255,0.5);
            padding: 8px 15px; border-radius: 20px;
            font-size: 14px; backdrop-filter: blur(5px);
            display: none; cursor: pointer;
        }

        /* è°ƒè¯•æ—¥å¿— */
        #debug-log {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 100px;
            background: linear-gradient(to top, rgba(0,0,0,0.8), rgba(0,0,0,0)); 
            color: #00ff00; font-size: 10px; padding: 10px; 
            overflow-y: scroll; z-index: 101; pointer-events: none;
            font-family: monospace;
        }
    </style>
    
    <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
</head>
<body>

    <button id="switch-btn">ğŸ“· åˆ‡æ¢æ‘„åƒå¤´</button>

    <div id="overlay">
        <h1>ğŸ‘‹ Labubu AR</h1>
        <div id="loading-status" style="margin: 20px 0; color: #aaa;">æ­£åœ¨é¢„åŠ è½½èµ„æº...</div>
        <button id="start-btn" disabled>èµ„æºåŠ è½½ä¸­...</button>
    </div>

    <div id="debug-log"></div>
    <video id="input-video" playsinline webkit-playsinline></video>
    <canvas id="output-canvas"></canvas>

    <script>
        // --- æ—¥å¿— ---
        function log(msg) {
            const logDiv = document.getElementById('debug-log');
            const time = new Date().toTimeString().split(' ')[0];
            logDiv.innerHTML = `[${time}] ${msg}<br>` + logDiv.innerHTML;
            console.log(msg);
        }

        // --- å…¨å±€å˜é‡ ---
        let scene, camera, renderer, labubuGroup;
        let hands, cameraUtils;
        let isFrontCamera = true; // é»˜è®¤å‰ç½®
        let isRunning = false;

        const startBtn = document.getElementById('start-btn');
        const switchBtn = document.getElementById('switch-btn');
        const statusDiv = document.getElementById('loading-status');
        const videoElement = document.getElementById('input-video');
        const canvasElement = document.getElementById('output-canvas');

        // --- 1. é¡µé¢åŠ è½½ ---
        window.onload = function() {
            if (typeof THREE === 'undefined' || typeof Hands === 'undefined') {
                statusDiv.innerText = "ç½‘ç»œæ³¢åŠ¨ï¼Œå»ºè®®åˆ·æ–°é‡è¯•";
                statusDiv.style.color = "red";
                log("âŒ ä¾èµ–åº“åŠ è½½å¤±è´¥");
                return;
            }
            startBtn.disabled = false;
            startBtn.innerText = "ç‚¹å‡»å¼€å§‹ä½“éªŒ";
            statusDiv.innerText = "å‡†å¤‡å°±ç»ª";
        };

        // --- 2. å¯åŠ¨ç¨‹åº ---
        async function startApp() {
            startBtn.disabled = true;
            statusDiv.innerText = "å¯åŠ¨å¼•æ“ä¸­...";

            try {
                initThreeJS();
                initMediaPipe();
                await startCamera('user'); // é»˜è®¤å¯åŠ¨å‰ç½®

                // å¯åŠ¨æˆåŠŸå
                document.getElementById('overlay').style.display = 'none';
                switchBtn.style.display = 'block'; // æ˜¾ç¤ºåˆ‡æ¢æŒ‰é’®
                isRunning = true;

            } catch (e) {
                log("âŒ å¯åŠ¨æŠ¥é”™: " + e.message);
                statusDiv.innerText = "å¯åŠ¨å¤±è´¥ï¼Œè¯·æŸ¥çœ‹æ—¥å¿—";
                startBtn.disabled = false;
            }
        }

        // --- 3. Three.js 3D åˆå§‹åŒ– ---
        function initThreeJS() {
            log("åˆå§‹åŒ– 3D...");
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;

            renderer = new THREE.WebGLRenderer({ canvas: canvasElement, alpha: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);

            scene.add(new THREE.AmbientLight(0xffffff, 0.8));
            const dirLight = new THREE.DirectionalLight(0xffffff, 1);
            dirLight.position.set(5, 10, 7);
            scene.add(dirLight);

            labubuGroup = new THREE.Group();
            scene.add(labubuGroup);

            // >>> å ä½æ¨¡å‹ (æ—‹è½¬æ–¹å—) <<<
            const geometry = new THREE.BoxGeometry(1.5, 1.5, 1.5);
            const material = new THREE.MeshNormalMaterial(); 
            const cube = new THREE.Mesh(geometry, material);
            labubuGroup.add(cube);
            labubuGroup.visible = false;

            /* // >>> Labubu æ¨¡å‹åŠ è½½ä»£ç  (å–æ¶ˆæ³¨é‡Šä½¿ç”¨) <<<
            const loader = new THREE.GLTFLoader();
            loader.load('./labubu.glb', (gltf) => {
                labubuGroup.clear();
                const model = gltf.scene;
                model.scale.set(0.5, 0.5, 0.5);
                labubuGroup.add(model);
                log("âœ… æ¨¡å‹åŠ è½½å®Œæ¯•");
            }); */
        }

        // --- 4. AI åˆå§‹åŒ– ---
        function initMediaPipe() {
            hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });
            hands.onResults(onResults);
        }

        // --- 5. æ‘„åƒå¤´æ ¸å¿ƒé€»è¾‘ (æ”¯æŒåˆ‡æ¢) ---
        async function startCamera(facingMode) {
            log(`æ­£åœ¨å¯åŠ¨æ‘„åƒå¤´: ${facingMode}...`);
            
            // å¦‚æœå·²æœ‰æ‘„åƒå¤´åœ¨è¿è¡Œï¼Œå…ˆåœæ­¢
            if (cameraUtils) {
                await cameraUtils.stop();
            }

            // è°ƒæ•´é•œåƒ CSSï¼šå‰ç½®éœ€è¦é•œåƒç¿»è½¬ï¼Œåç½®ä¸éœ€è¦
            if (facingMode === 'user') {
                videoElement.style.transform = "scaleX(-1)";
                canvasElement.style.transform = "scaleX(-1)";
            } else {
                videoElement.style.transform = "scaleX(1)";
                canvasElement.style.transform = "scaleX(1)";
            }

            cameraUtils = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 1280,
                height: 720,
                facingMode: facingMode // å…³é”®é…ç½®
            });

            await cameraUtils.start();
            log("âœ… æ‘„åƒå¤´è¿è¡Œä¸­");
        }

        // --- 6. åˆ‡æ¢æŒ‰é’®é€»è¾‘ ---
        switchBtn.addEventListener('click', async () => {
            if (!isRunning) return;
            
            switchBtn.disabled = true;
            switchBtn.innerText = "åˆ‡æ¢ä¸­...";
            
            // åˆ‡æ¢æ¨¡å¼
            isFrontCamera = !isFrontCamera;
            const mode = isFrontCamera ? 'user' : 'environment';
            
            try {
                await startCamera(mode);
            } catch (e) {
                log("åˆ‡æ¢å¤±è´¥: " + e);
                alert("åˆ‡æ¢æ‘„åƒå¤´å¤±è´¥ï¼Œè¯·åˆ·æ–°é‡è¯•");
            }
            
            switchBtn.disabled = false;
            switchBtn.innerText = isFrontCamera ? "ğŸ“· åˆ‡åˆ°åç½®" : "ğŸ“· åˆ‡åˆ°å‰ç½®";
        });

        // --- 7. æ¸²æŸ“å¾ªç¯ ---
        function onResults(results) {
            if (!renderer || !labubuGroup) return;

            canvasCtx = canvasElement.getContext('2d');
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                // ä¸­æŒ‡æ ¹éƒ¨
                const palmX = landmarks[9].x; 
                const palmY = landmarks[9].y;
                
                update3DPosition(palmX, palmY, landmarks);
                labubuGroup.visible = true;
            } else {
                labubuGroup.visible = false;
            }
            renderer.render(scene, camera);
        }

        function update3DPosition(x, y, landmarks) {
            const vec = new THREE.Vector3();
            // åæ ‡æ˜ å°„
            vec.set((x * 2) - 1, -(y * 2) + 1, 0.5);
            vec.unproject(camera);
            vec.sub(camera.position).normalize();
            
            // ç®€å•çš„æ·±åº¦ä¼°ç®—
            const dx = landmarks[0].x - landmarks[9].x;
            const dy = landmarks[0].y - landmarks[9].y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            
            // åç½®æ‘„åƒå¤´é€šå¸¸æ‰‹ä¼šæ¯”è¾ƒå°ï¼Œè°ƒæ•´ä¸€ä¸‹æ·±åº¦ç³»æ•°
            const depthFactor = isFrontCamera ? 5 : 8; 
            const zDepth = 1 / (dist * depthFactor); 
            
            var dir = vec.multiplyScalar(zDepth);
            labubuGroup.position.copy(camera.position).add(dir);
            labubuGroup.rotation.y += 0.01; // æ—‹è½¬åŠ¨ç”»
        }

        startBtn.addEventListener('click', startApp);
        
        window.addEventListener('resize', () => {
            if(camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });
    </script>
</body>
</html>
